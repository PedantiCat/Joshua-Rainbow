{"hash":"e68e4960fd514a7c810669dc81d1a83c16a9c8d5","data":{"programming":{"id":"d24d249c7fa55ecd9efe3bcb2e5b1296","title":"Last.fm Tag Cloud Generator","github":"https://github.com/TheTeaCat/lastfm-tag-cloud","content":"<h1 id=\"lastfm-tag-cloud\"><a href=\"#lastfm-tag-cloud\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>lastfm-tag-cloud</h1>\n<p>A last.fm tag cloud generator built with Vue!</p>\n<p>Give it a whirl: <a href=\"https://theteacat.github.io/lastfm-tag-cloud/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">theteacat.github.io/lastfm-tag-cloud/</a></p>\n<h2 id=\"how-are-the-tags-chosen--scaled\"><a href=\"#how-are-the-tags-chosen--scaled\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>How are the tags chosen &#x26; scaled?</h2>\n<p>Initially, the sample of artists (up to the size and of the time period you specify) is iterated through. For each artist, their top tags are fetched, using <a href=\"https://www.last.fm/api/show/artist.getTopTags\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">artist.getTopTags</a>. </p>\n<p>Each tag in the response has a <code>count</code> for that artist.</p>\n<blockquote>\n<p><strong>Note:</strong> This <code>count</code> doesn't seem to be documented anywhere. They cap out at 100, so I am working under the assumption that they're a kind of confidence % as to how apropriate that tag is for that artist.</p>\n</blockquote>\n<p>For each tag on the artist, the tag's <code>count</code> is added to that tag's <code>library_total</code> metric.</p>\n<p>This <code>library_total</code> metric is created with an initial value of <code>0</code> for every tag.</p>\n<p>Once all of the artists are iterated through, the tags are pruned to the top 100 by this <code>library_total</code> metric. This is done to avoid hitting rate limits on the last.fm API in the next step, where I have to call <a href=\"https://www.last.fm/api/show/tag.getInfo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tag.getInfo</a> for every tag.</p>\n<p>Each of these 100 tags is then scored as per the following code snippet [<a href=\"https://github.com/TheTeaCat/lastfm-tag-cloud/blob/master/src/assets/js/Generator.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">source</a>]:</p>\n<pre><code class=\"language-javascript\">score_tags(result){\n    for (var tag of result.tags) {\n        result.scores[tag] = 0\n        /**First, each tagging is weighted by the product of:\n         *  - How many times the user has listened to the artist on which the tag was used,\n         * and...\n         *  - The \"count\" of that tag on the artist.\n         *    I am assuming that this \"count\" is a confidence % given by last.fm as to the accuracy of the tag on that artist.\n         *    I can't find any doccumentation, but this would make sense, as they cap out at 100.\n         */\n        for (var tagging of result.taggings[tag]) {\n            result.scores[tag] += tagging.count/100 * result.listens[tagging.artist]\n        }\n        /**The sum of all these weighted taggings is then scaled by:\n         * 1. How many of the uses of that tag overall fall within the user's library sample (its \"uniqueness\" to the sample).\n         * \n         * 2. How many artists within the sample are tagged with that tag (its \"spread\" over the sample).\n         * \n         * 3. The base 10 logarithm of how many people have used that tag overall (its \"reach\"; see last.fm API docs).\n         *    Base 10 is used so 100 people using the tag makes it twice as significant as 10 people using the tag; a nice balance.\n         *    It's also conveniently provided as a function by Math.\n         */\n        result.scores[tag] = result.scores[tag] \n                                    * (result.tag_meta[tag].library_total / result.tag_meta[tag].total) \n                                    * result.taggings[tag].length * result.taggings[tag].length\n                                    * Math.log10(result.tag_meta[tag].reach)\n    }\n}\n</code></pre>\n<p><code>tag_meta[tag].total</code> is the <code>taggings</code> metric for that tag, taken from <a href=\"https://www.last.fm/api/show/tag.getInfo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tag.getInfo</a>.</p>\n<p><code>taggings[tag]</code> is an array of all the artists that were tagged that tag.</p>\n<p><code>tag_meta[tag].reach</code> is the <code>reach</code> metric for that tag, taken from <a href=\"https://www.last.fm/api/show/tag.getInfo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tag.getInfo</a>.</p>\n<p>I've tried to make this take into account the \"uniqueness\" of the tag to a user's library, as if they were all just scored by frequency the biggest tag on everyone's clouds would probably just be \"all\".</p>\n<p>If this causes issues for you, I know. See <a href=\"https://github.com/TheTeaCat/lastfm-tag-cloud/issues/10\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>. I don't care. :rowboat:</p>\n<h2 id=\"what-does-the-tag-filter-do\"><a href=\"#what-does-the-tag-filter-do\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What does the tag filter do?</h2>\n<p>The tag filter checks tags against an offensive word list, \"all\", \"seen live\" and a geohash filter to remove tags that are overly generic/obscene.</p>\n<p>The source of the tag filter's offensive word list is <a href=\"https://www.ofcom.org.uk/__data/assets/pdf_file/0022/91624/OfcomOffensiveLanguage.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ofcom's September 2016 Attitudes to potentially offensive language and gestures on TV and radio research report</a>. Those used are the medium, strong, and stronger words that are <strong>not</strong> marked as \"least recognised\".</p>\n<h2 id=\"acknowledgements\"><a href=\"#acknowledgements\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Acknowledgements</h2>\n<p>I'm using <a href=\"https://github.com/timdream/wordcloud2.js/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">timdream's word cloud generator</a>.</p>\n"}},"context":{}}